// Generated by CoffeeScript 1.12.4
(function() {
  var args, os, path, utils;

  os = require('os');

  path = require('path');

  utils = require(__dirname + "/utils");

  args = require('subarg')(process.argv.slice(2), {
    alias: {
      d: 'debug',
      f: 'file',
      h: 'help',
      p: 'pedantic'
    }
  });

  if (args.pedantic) {
    exports.pedantic_ret = 'failed';
    exports.pedantic_severity = 'ERROR';
  } else {
    exports.pedantic_ret = 'warning';
    exports.pedantic_severity = 'WARN';
  }

  exports.all = ['from_first', 'no_empty_tag', 'no_empty_digest', 'json_array_brackets', 'json_array_even_quotes', 'json_array_format', 'env', 'recommended_exec_form', 'add', 'multiple_entries', 'sudo', 'absolute_workdir', 'onbuild_copyadd', 'onbuild_disallowed', 'label_no_empty_value'];

  exports.env = [];

  Array.prototype.filter = function(func) {
    var j, len, ref, results, x;
    ref = this;
    results = [];
    for (j = 0, len = ref.length; j < len; j++) {
      x = ref[j];
      if (func(x)) {
        results.push(x);
      }
    }
    return results;
  };

  exports.getAll = function(instruction, rules) {
    return rules.filter(function(r) {
      return r.instruction === instruction;
    });
  };

  exports.getAllExcept = function(instruction, rules) {
    return rules.filter(function(r) {
      return r.instruction !== instruction;
    });
  };

  exports.from_first = function(rules) {
    var first, non_comments;
    non_comments = this.getAllExcept('comment', rules);
    first = non_comments[0];
    if (first.instruction !== 'FROM') {
      utils.log('ERROR', "First instruction must be 'FROM', is: " + first.instruction);
      return 'failed';
    }
    return 'ok';
  };

  exports.no_empty_tag = function(rules) {
    var from, image, j, len, ref, rule, tag;
    from = this.getAll('FROM', rules);
    for (j = 0, len = from.length; j < len; j++) {
      rule = from[j];
      if (rule["arguments"][0].match(/:/)) {
        ref = rule["arguments"][0].split(':'), image = ref[0], tag = ref[1];
        if (!utils.notEmpty(tag)) {
          utils.log('ERROR', "Tag must not be empty for \"" + image + "\" on line " + rule.line);
          return 'failed';
        }
      }
    }
    return 'ok';
  };

  exports.no_empty_digest = function(rules) {
    var digest, from, image, j, len, ref, rule;
    from = this.getAll('FROM', rules);
    for (j = 0, len = from.length; j < len; j++) {
      rule = from[j];
      if (rule["arguments"][0].match(/@/)) {
        ref = rule["arguments"][0].split('@'), image = ref[0], digest = ref[1];
        if (!utils.notEmpty(digest)) {
          utils.log('ERROR', "Digest must not be empty for \"" + image + "\" on line " + rule.line);
          return 'failed';
        }
      }
    }
    return 'ok';
  };

  exports.json_array_format = function(rules) {
    var arg, argument, errmsg, i, j, k, l, len, len1, len2, len3, m, r, ref, ref1, ref2, rule;
    ref = ['CMD', 'ENTRYPOINT', 'RUN', 'VOLUME'];
    for (j = 0, len = ref.length; j < len; j++) {
      i = ref[j];
      rule = this.getAll(i, rules);
      for (k = 0, len1 = rule.length; k < len1; k++) {
        r = rule[k];
        errmsg = "Arguments to " + i + " in exec form must not contain single quotes on line " + r.line;
        ref1 = r["arguments"];
        for (l = 0, len2 = ref1.length; l < len2; l++) {
          argument = ref1[l];
          if (argument.match(/^\[.*\]/)) {
            ref2 = argument.split(/,(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/, -1);
            for (m = 0, len3 = ref2.length; m < len3; m++) {
              arg = ref2[m];
              if (!arg.trim().match(/^\[?(\s+)?\".*\"(\s+)?\]?$/)) {
                utils.log('ERROR', errmsg);
                return 'failed';
              }
            }
          } else {
            if (argument.match(/\[.*'.*\]/)) {
              utils.log('ERROR', errmsg);
              return 'failed';
            }
          }
        }
      }
    }
    return 'ok';
  };

  exports.json_array_even_quotes = function(rules) {
    var i, j, k, len, len1, quotes, r, ref, rule;
    ref = ['CMD', 'ENTRYPOINT', 'RUN', 'VOLUME'];
    for (j = 0, len = ref.length; j < len; j++) {
      i = ref[j];
      rule = this.getAll(i, rules);
      for (k = 0, len1 = rule.length; k < len1; k++) {
        r = rule[k];
        quotes = r["arguments"].join(' ').split('"');
        if (!(quotes.length % 2)) {
          utils.log('ERROR', "Odd number of double quotes on line " + r.line);
          return 'failed';
        }
      }
    }
    return 'ok';
  };

  exports.json_array_brackets = function(rules) {
    var arg2json, e, i, j, k, len, len1, nArray, r, ref, rule;
    ref = ['CMD', 'ENTRYPOINT', 'RUN', 'VOLUME'];
    for (j = 0, len = ref.length; j < len; j++) {
      i = ref[j];
      rule = this.getAll(i, rules);
      for (k = 0, len1 = rule.length; k < len1; k++) {
        r = rule[k];
        if (!r["arguments"][0].match(/(^\s*\[)|(\]\s*$)/g)) {
          continue;
        }
        try {
          arg2json = JSON.parse(r["arguments"].join(' '));
          nArray = arg2json.filter(function(z) {
            return utils.isArray(z);
          });
          if (nArray.length > 0) {
            utils.log('ERROR', "Nested array found on line " + r.line);
            return 'failed';
          }
          return 'ok';
        } catch (error) {
          e = error;
          utils.log('ERROR', "Invalid array on line " + r.line);
          return 'failed';
        }
      }
    }
  };

  exports.recommended_exec_form = function(rules) {
    var i, j, k, lbracket, len, len1, nr, r, rbracket, ref, rule;
    ref = ['CMD', 'ENTRYPOINT'];
    for (j = 0, len = ref.length; j < len; j++) {
      i = ref[j];
      rule = this.getAll(i, rules);
      for (k = 0, len1 = rule.length; k < len1; k++) {
        r = rule[k];
        nr = r["arguments"].join(' ').split(/,(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/, -1);
        lbracket = nr[0].match(/\[/g);
        rbracket = nr[nr.length - 1].match(/\]/g);
        if ((lbracket == null) || (rbracket == null)) {
          utils.log(exports.pedantic_severity, "Recommended exec/array form not used on line " + r.line);
          return exports.pedantic_ret;
        }
      }
    }
    return 'ok';
  };

  exports.add = function(rules) {
    var add, j, len, lines, rule;
    add = this.getAll('ADD', rules);
    if (add.length > 0) {
      lines = [];
      for (j = 0, len = add.length; j < len; j++) {
        rule = add[j];
        if (!rule["arguments"][0].match(/\.(tar|gz|bz2|xz)/)) {
          lines.push(rule.line);
        }
      }
      if (lines.length > 0) {
        utils.log(exports.pedantic_severity, "ADD instruction used instead of COPY on line " + (lines.join(', ')));
        return exports.pedantic_ret;
      }
    }
    return 'ok';
  };

  exports.multiple_entries = function(rules) {
    var e, j, len, ref, rule;
    ref = ['CMD', 'ENTRYPOINT'];
    for (j = 0, len = ref.length; j < len; j++) {
      e = ref[j];
      rule = this.getAll(e, rules);
      if (rule.length > 1) {
        utils.log('ERROR', "Multiple " + e + " instructions found, only line " + rule[rule.length - 1].line + " will take effect");
        return 'failed';
      }
    }
    return 'ok';
  };

  exports.sudo = function(rules) {
    var argument, j, k, len, len1, ref, rule, run;
    run = this.getAll('RUN', rules);
    for (j = 0, len = run.length; j < len; j++) {
      rule = run[j];
      ref = rule["arguments"];
      for (k = 0, len1 = ref.length; k < len1; k++) {
        argument = ref[k];
        if (argument.match(/(^|.*;)\s*(\/?.*\/)?sudo(\s|$)/)) {
          utils.log(exports.pedantic_severity, "sudo(8) usage found on line " + rule.line + " which is discouraged");
          return exports.pedantic_ret;
        }
      }
    }
    return 'ok';
  };

  exports.env = function(rules) {
    var argument, env, environs, j, k, l, len, len1, len2, p, pair, ref, ref1, rule;
    environs = this.getAll('ENV', rules);
    for (j = 0, len = environs.length; j < len; j++) {
      rule = environs[j];
      ref = rule["arguments"];
      for (k = 0, len1 = ref.length; k < len1; k++) {
        argument = ref[k];
        if (argument.split(' ')[0].match(/(\w+)=([^\s]+)/)) {
          ref1 = argument.split(' ');
          for (l = 0, len2 = ref1.length; l < len2; l++) {
            pair = ref1[l];
            p = pair.split(/(\w+)=([^\s]+)/);
            exports.env['$' + p[1]] = p[2];
          }
        } else {
          env = argument.match(/^(\S+)\s(.*)/);
          if (env) {
            env = env.slice(1);
          } else {
            utils.log('ERROR', "ENV invalid format " + rule["arguments"] + " on line " + rule.line);
            return 'failed';
          }
          if (env[0] && env[1]) {
            exports.env['$' + env[0]] = env[1];
          } else {
            utils.log('ERROR', "ENV invalid format " + rule["arguments"] + " on line " + rule.line);
            return 'failed';
          }
        }
      }
    }
    return 'ok';
  };

  exports.absolute_workdir = function(rules) {
    var absolute, env, j, len, rule, workdir;
    workdir = this.getAll('WORKDIR', rules);
    for (j = 0, len = workdir.length; j < len; j++) {
      rule = workdir[j];
      env = rule["arguments"][0].match(/\$[\w]+/);
      if (exports.env[env]) {
        rule["arguments"][0] = rule["arguments"][0].replace(env, exports.env[env]);
      } else if (env) {
        utils.log('ERROR', "WORKDIR path " + rule["arguments"] + " contains undefined ENV variable on line " + rule.line);
        return 'failed';
      }
      if (typeof path.isAbsolute !== "undefined") {
        absolute = path.isAbsolute(rule["arguments"][0]);
      } else {
        absolute = rule["arguments"][0].charAt(0) === '/';
      }
      if (!absolute) {
        utils.log('ERROR', "WORKDIR path " + rule["arguments"] + " must be absolute on line " + rule.line);
        return 'failed';
      }
    }
    return 'ok';
  };

  exports.onbuild_copyadd = function(rules) {
    var argument, j, k, len, len1, onbuild, ref, rule;
    onbuild = this.getAll('ONBUILD', rules);
    for (j = 0, len = onbuild.length; j < len; j++) {
      rule = onbuild[j];
      ref = rule["arguments"];
      for (k = 0, len1 = ref.length; k < len1; k++) {
        argument = ref[k];
        if (argument.match(/ADD|COPY/)) {
          utils.log(exports.pedantic_severity, "It is advised not to use ADD or COPY for ONBUILD on line " + rule.line);
          return exports.pedantic_ret;
        }
      }
    }
    return 'ok';
  };

  exports.onbuild_disallowed = function(rules) {
    var argument, chained_instruction, j, k, len, len1, onbuild, ref, rule;
    onbuild = this.getAll('ONBUILD', rules);
    for (j = 0, len = onbuild.length; j < len; j++) {
      rule = onbuild[j];
      ref = rule["arguments"];
      for (k = 0, len1 = ref.length; k < len1; k++) {
        argument = ref[k];
        chained_instruction = argument.split(' ')[0];
        if (chained_instruction.match(/ONBUILD|FROM|MAINTAINER/)) {
          utils.log('ERROR', "ONBUILD may not be chained with " + chained_instruction + " on line " + rule.line);
          return 'failed';
        }
      }
    }
    return 'ok';
  };

  exports.label_no_empty_value = function(rules) {
    var argument, j, k, l, label, len, len1, len2, pair, ref, ref1, rule;
    label = this.getAll('LABEL', rules);
    for (j = 0, len = label.length; j < len; j++) {
      rule = label[j];
      ref = rule["arguments"];
      for (k = 0, len1 = ref.length; k < len1; k++) {
        argument = ref[k];
        ref1 = argument.split(' ');
        for (l = 0, len2 = ref1.length; l < len2; l++) {
          pair = ref1[l];
          if (pair.slice(-1) === '=') {
            utils.log('ERROR', "LABEL requires value for line " + rule.line);
            return 'failed';
          }
        }
      }
    }
    return 'ok';
  };

}).call(this);
